/* GIT - РАСПРЕДЕЛЕННАЯ СИСТЕМА УПРАВЛЕНИЯ ВЕРСИЯМИ
 * - система управления версиями:
 *      - регистрирует изменения в 1 или нескольких файлах, чтобы потом можно было вернуться к
 *      определённым старым версиям этих файлов
 *
 * - распределенная
 *       - т.к. полная копия репозитория хранится у каждого клиента
 *          - чтобы избежать проблем с сервером
 *       - также клиенты не завязаны на сервер и могут работать группами
 *          - простым указанием удаленного адреса и нужной ветки */


/* БОЛЬШИНСТВО ОПЕРАЦИЙ ЛОКАЛЬНЫЕ (И, СЛЕДОВАТЕЛЬНО, БЫСТРЫЕ)
 * - т.к. вся история хранится на диске
 * - коммиты можно делать без доступа к интернету
 *      - и только потом отправить все на сервер*/


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ОСНОВНОЕ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* РЕПОЗИТОРИЙ
 * - содержит:
 *      - файлы конфигурации репозитория
 *      - файлы журналов
 *          - хранят операции, выполняемые над репозиторием
 *      - индекс
 *          - список отслеживаемых файлов и их путей
 *      - хранилище
 *          - содержит сами файлы
 *          - не отражает реальную структуру хранящегося в репозитории файлового дерева
 *              - ориентирована на повышение скорости выполнения операций над репозиторием
 *      - ссылки на ветки
 *      - теги
 *      - ссылка для HEAD */


/* СНИМКИ ВМЕСТО ПАТЧЕЙ, ИНДЕКС И КОММИТ
 * - большинство других систем хранит информацию как последовательность изменений (патчей) для
 * файлов
 *      - патч - файл, описывающий изменения в файле
 *          - т.е. разница (дельта)
 *      - т.е. оригинальный файл и его патчи, соответствующие версиям этого файла
 *
 * - Git хранит данные как последовательность снимков небольшой файловой системы (каталога)
 *      - при каждой фиксации (коммите) сохраняется полный снимок всех файлов каталога
 *          - для оптимизации, если файл не изменился, то делается ссылка на ранее сохраненную версию
 *
 *      - до коммита все файлы "помещаются" в индекс
 *          - обычно .git/index
 *          - двоичный файл
 *          - служит как "область подготовленных файлов" для записи объекта-дерева (каталога) в
 *          коммит
 *              - можно считать снимком следующего намеченного коммита
 *              - см. 3 состояния файлов и 3 части проекта
 *          - содержит список путей
 *              - для каждого указаны:
 *                  - разрешения
 *                  - контрольная сумма (SHA-1) соответствующего blob объекта
 *                      - все пользовательские файлы хранятся в репозитории как blob объекты
 *                      - blob объекты будут добавлены в репозиторий при коммите
 *                      - см. целостность данных
 *
 *      - при фиксации (коммите) в репозитории сохраняются:
 *          - по 1 blob объекту для каждого файла
 *          - объект-дерево, содержащее указатели на эти blob-объекты
 *          - объект-коммит, который содержит:
 *              - указатель на объект-дерево
 *              - метаданные автора коммита и комментария
 *              - указатель/указатели на коммиты-предки
 *                  - 0 для первого коммита
 *                  - 1 для обычного коммита
 *                  - 2 для коммита, полученного при слиянии 2 веток
 *
 *      - ссылки на все объекты (blob, деревья и коммиты) представлены контрольными суммами SHA-1
 *
 * - Git работает только с файлами и их содержимым и не отслеживает пустые каталоги
 *      - чтобы они тоже отслеживались, в них нужно просто вставить какой-нибудь файл
 *          - напр. .gitkeep*/


/* ЦЕЛОСТНОСТЬ ДАННЫХ
 * - перед сохранением файла вычисляется контрольная сумма
 *      - становится индексом этого файла
 *      - механизм вычисления суммы - SHA-1 хеш
 *          - на основе содержимого файла или структуры каталога
 *          - 40 16-ричных символов
 *              - напр. 24b9da6552252987aa493b52f8696cd6d3b00373
 *      - Git сохраняет все в своей базе данные не по именам, а по хешам
 *      - невозможно изменить содержимое файла или каталога в обход Git
 *
 * - в целом, все что попадает в коммит, может быть восстановлено
 *      - поэтому не закомиченные изменения можно потерять навсегда
 *          - напр. при reset --hard */


/* 3 СОСТОЯНИЯ ФАЙЛОВ И 3 ЧАСТИ ПРОЕКТА
 * - ЗАФИКСИРОВАННОЕ состояние:
 *      - файл уже сохранен в локальной базе
 *      - такие файлы находятся в "КАТАЛОГЕ GIT"
 *          - в каталоге находятся:
 *              - метаданные
 *              - база данных объектов проекта
 *          - передается при клонировании репозитория с другого места
 *
 * - ИЗМЕНЕННОЕ состояние:
 *      - файл, который поменялся, но еще не зафиксирован
 *      - такие файлы находятся в "РАБОЧЕМ КАТАЛОГЕ"
 *          - рабочий каталог - извлеченная из базы копия определенной версии проекта
 *              - файлы достаются из сжатой базы данных в каталоге Git и помещаются на диск для
 *              редактирования
 *              - т.е. это просто файлы, которые я вижу и с которыми могу работать
 *              - если рабочая версия файла совпадает с версией в каталоге Git, то он считается
 *              зафиксированным и не участвует в коммите
 *              - при редактировании отслеживаемого файла в рабочем каталоге, он становится измененным
 *                  - или при первичном добавлении файла в отслеживание
 *
 * - ПОДГОТОВЛЕННОЕ (ПРОИНДЕКСИРОВАННОЕ) состояние:
 *      - измененный файл, который включен в следующий коммит
 *          - т.е. снимок
 *      - такие файлы находятся в "ОБЛАСТИ ПОДГОТОВЛЕННЫХ ФАЙЛОВ (ИНДЕКСЕ)"
 *          - область подготовленных файлов - обычный файл:
 *              - хранится в каталоге Git
 *              - содержит информацию о том, что должно войти в следующий коммит
 *
 * - файл может быть одновременно в подготовленном и измененном состоянии
 *      - если были изменения после подготовленного состояния и до фиксированного */


/* ОТСЛЕЖИВАЕМЫЕ И НЕ ОТСЛЕЖИВАЕМЫЕ ФАЙЛЫ
 *  - любой файл в рабочем каталоге может быть отслеживаемым или не отслеживаемым
 *
 * - отслеживаемый файл:
 *      - был в последнем снимке
 *      - может быть:
 *          - неизмененным
 *              - соответствует последнему зафиксированному состоянию
 *          - измененным
 *              - не соответствует последнему зафиксированному состоянию
 *          - подготовленным к коммиту
 *              - находится в индексе
 *
 * - не отслеживаемым
 *      - не входил в последний снимок
 *      - не подготавливался к коммиту */


/* СОЗДАНИЕ РЕПОЗИТОРИЯ (2 ВИДА)
 * - импорт в Git существующего проекта или каталога:
 *       - перейти в проектный каталог
 *       - ввести git init
 *           - создается новый подкатолог .git
 *               - содержит все файлы репозитория
 *       - проиндексировать файлы:
 *          - git add .
 *              - многофунциональная команда:
 *                  - добавление отслеживания для новых файлов + помещение их в индекс
 *                  - помещение старых файлов в индекс
 *                      - т.е. подготовка (помечивание) всех изменений для коммита
 *                  - и т.д.
 *       - произвести первое фиксирование изменений:
 *          - git commit -m 'message'
 *
 * - клонирование существующего репозиторая с сервера:
 *       - git clone [url]
 *           - копируется почти вся информация с сервера
 *           - напр. git clone git://github.com/schacon/grit.git
 *               - создает каталог grit
 *               - инициализирует внутри каталог .git
 *               - скачивает все данные репозитория
 *               - т.е. создает локальную рабочую копию репозитория
 *       - изменить название создаваемого каталога: git clone [url] [name]
 *       - все файлы сразу отслеживаемые и неизмененные
 *       - разные версии транспортных протоколов:
 *           - git://
 *           - http(s)://
 *           - user@server:/path.git
 *               - SSH */


/* GIT STATUS И GIT DIFF
 * - git status: показать статус рабочего каталога
 *      - на какой ветке находится
 *      - комментарии коммитов
 *      - присутствие изменений в отслеживаемых файлах, которые могут быть закомичены
 *      - присутствие изменений в отслеживаемых файлах, которые пока не могут быть закомичены
 *          - т.е. не добавлены в область подготовленных файлов
 *      - неотслеживаемые файлы
 *
 * - git diff: показать изменения между коммитами, коммитом и рабочим каталогом и т.д.
 *      - git diff
 *          - показать только не проиндексированные изменения
 *      - git diff --staged (или git diff --cached)
 *          - показать, что проиндексировано и войдет в следующий коммит
 *      - см. также git log -p */


/* GIT COMMIT - ФИКСАЦИЯ ИЗМЕНЕНИЙ, ИГНОРИРОВАНИЕ ИНДЕКСАЦИИ ИЗМЕНЕННЫХ ФАЙЛОВ
 * - в коммит идет только то, что проиндексировано
 *
 * - вызывает текстовый редактор
 *      - с подготовленным закоментированным текстом из status
 *          - git commit -v: добавить еще и diff к status
 *          - закоментированный текст не передается
 *
 * - git commit -m "My text without text editor": передает строку без вызова текстового редактора
 *
 * - возвращает:
 *      - контрольную сумму коммита
 *      - число измененных файлов и статистику вставок удалений строк
 *
 * - git commit -a
 *      - пропустить индексацию файлов и закоммитить все изменения сразу из рабочего каталога
 *          - т.е. перед коммитом автоматически добавить все измененные файлы в индекс */


/* GIT LOG - ИСТОРИЯ КОММИТОВ
 * - git log: список коммитов для репозитория в обратном хронологическом порядке
 *      - контрольная сумма
 *      - автор
 *      - дата создания
 *      - комментарий
 *
 * - git log -2: ограничение списка (последних) коммитов для вывода
 *      - другие параметры:
 *          --since
 *          --after
 *          --until
 *          --before
 *          --author
 *              - тот, кто писал файл
 *          --commiter
 *              - тот, кто коммитил
 *          --grep
 *              - поиск по ключевым словам в комментарии
 *          --../
 *              - ограничение по пути
 *              - указывается всегда последней
 *              - напр.
 *                  -- t/
 *
 * - git log -p: разница (diff) между коммитами на уровне строк
 *      - git log -p --word-diff: разница между коммитами на уровне слов
 *          - добавленное слово заключено в {+ +}, а удалённое в [- -]
 *          - git log -U1 -p --word-diff: сокращение контекста до 1 строки (вместо 3)
 *
 * - git log --stat: краткая статистика по каждому коммиту
 *      - список изменённых файлов
 *      - количество изменённых файлов
 *      - количество добавленных и удалённых строк в этих файлах
 *      - сводная информация в конце
 *
 * - git log --pretty: меняет формат вывода
 *      - git log --pretty=oneline: 1 коммит помещается в 1 строку
 *          - напр. ca82a6dff817ec66f44342007202690a93763949 changed the version number
 *      - параметр format позволяет создать свой формат вывода лога
 *          - напр. git log --pretty=format:"%h - %an, %ar : %s"
 *          - см. все возможные параметры в книжке
 *      - другие возможные параметры:
 *          - short, full, fuller
 *
 * - git log --graph: показывает историю красывым графом
 *          - напр. git log --pretty=format:"%h %s" --graph
 *
 * - gitk - графический интерфейс */


/* ОТМЕНА ИЗМЕНЕНИЙ, ПЕРЕМЕЩЕНИЕ HEAD
 * - отмена изменений последнего коммита: git commit --amend
 *      - когда нужно что-то добавить в коммит или изменить
 *          - напр. комментарий
 *      - если не было изменений после коммита, будет вызван редактор для изменения комментария
 *      - если были, файлы добавятся в коммит
 *          - todo у меня сработало только так: git commit --amend --allow-empty
 *      - работает только для последнего коммита
 *
 * - отмена изменений в рабочем каталоге: git checkout -- filename.exe
 *      - аккуратно! все внесенные изменения теряются
 *
 * - отмена индексации файла: git reset HEAD filename.exe
 *
 * - перемещение HEAD: git reset --soft/mixed/hard commitname
 *      - напр. A-B-C(master), при этом в C есть файлы в индексе (незакоммиченные) и в рабочей
 *      директории ("грязные")
 *          - git reset --soft B:
 *              - HEAD будет указывать на коммит B
 *              - рабочая директория:
 *                  - добавлены "грязные" файлы из рабочей директории C, которые там были до reset
 *                  на B
 *                  - все остальное - "чистое"
 *                      - т.е. соответствует коммиту B
 *              - индекс:
 *                  - добавлены файлы, которые составляют разницу между чистыми коммитами C и B
 *                  - добавлены незакомиченные файлы из индекса С
 *              - т.е. если бы в C не было грязных или незакоммиченных файлов перед переходом на B,
 *              то последующий git commit для B привел бы к коммиту, полностью идентичному чистому C
 *
 *          - git reset --mixed B или git reset B: дефолтный вариант
 *              - HEAD будет указывать на коммит B
 *              - рабочая директория:
 *                  - добавлены "грязные" файлы из рабочей директории C и незакоммиченные файлы из
 *                  индекса С
 *                  - добавлена вся разница между чистыми С и В
 *                  - все остальное - "чистое"
 *                      - т.е. соответствует коммиту B
 *              - индекс:
 *                  - ничего не добавлено
 *              - т.е. если бы в C не было грязных или незакоммиченных файлов перед переходом на B,
 *              то последующий git commit для B привел бы к коммиту, полностью идентичному чистому C
 *              только после добавления всех грязных файлов из рабочей директории в индекс
 *
 *          - git reset --hard B:
 *              - HEAD будет указывать на коммит B
 *              - рабочая директория:
 *                  - все - "чистое"
 *                      - т.е. соответствует коммиту B
 *                      - т.е. ничего грязного не перенесено
 *              - индекс:
 *                  - ничего не добавлено
 *              - т.е.:
 *                  - потерялось все, что было не закоммичено для С
 *                  - разница между C и B не была добавлена ни в рабочую директорию ни в индекс B
 *                      - поэтому привести B к C не получится
 *
 *          - ВНИМАНИЕ: после reset в логе не отображаются коммиты, которые следовали за тем, на
 *          который сейчас указывает HEAD! */



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ УДАЛЕННЫЕ РЕПОЗИТОРИИ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* GIT REMOTE - СПИСОК НАСТРОЕННЫХ УДАЛЕННЫХ СЕРВЕРОВ/ЛОКАЦИЙ ДЛЯ РЕПОЗИТОРИЯ
 * - т.е. среди списка вполне могут быть локации с других компьютеров и даже с этого же
 *      - и можно брать и у них
 *
 * - origin: дефолтное имя локации, с которой склонирован проект
 *
 * - git remote -v: посмотреть полный URL для получения и отправки
 *
 * - git remote show servername: детальная информация об удаленном репозитории
 *      - URL сервера
 *      - информация об отслеживаемых ветках
 *          - т.е. что с чем будет сливаться при push/pull
 *
 * - git remote add name URL: добавить новый удаленный репозиторий
 *      - теперь можно использовать имя вместо URL
 *
 * - git remote rename oldname newname: переименовать удаленный репозиторий
 *      - также изменит имена удаленных веток
 *
 * - git remote remove servername: удалить удаленный репозиторий */


/* FETCH, PULL И PUSH
 * - git fetch servername: получение отсутствующих у меня данных проекта без сливания (merge) с уже
 * существующими локально
 *      - слияние необходимо производить вручную
 *      - данные помещаются в "удаленную" локальную ветку origin/master (напр)
 *
 * - git pull: получение данных (fetch) и попытка их автоматически слить (merge) c локальными
 *      - локальная ветка должна быть настроена на отслеживание удаленной
 *          - git clone по дефолту настраивает локальную ветку master на отслеживание удаленной
 *          ветки master на сервере
 *
 * - git push servername branch: отправка ветки branch на удаленный репозиторий servername
 *      - нужно право на запись
 *      - с момента получения данных с сервера, никто другой не должен был туда заливать изменения
 *          - иначе сначала нужно сделать pull
 *      - если настроено отслеживание, то можно просто git push*/



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ВЕТКИ - ПРОСТЫЕ УКАЗАТЕЛИ НА КОММИТ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - для отклонения девелопмента от основного направления
 *      - ветки могут быть:
 *          - недолговечными: для исправления бага или добавления фичи
 *          - долговечными: напр. одна для стабильного кода (master), другая для разработки
 *          (development) и/или для предлагаемых изменений (proposed)
 *              - т.е. несколько уравней стабильности:
 *                  - master
 *                      - development / proposed
 *                          - feature / bugfix
 *
 * - по умолчанию:
 *      - называется master
 *      - указывает на последний коммит
 *      - при новом коммите указатель сдвигается автоматически
 *
 * - (напомню) коммиты знают своих предков */


/* GIT BRANCH - СОЗДАНИЕ, ОТОБРАЖЕНИЕ И УДАЛЕНИЕ ВЕТОК (УКАЗАТЕЛЕЙ)
 * - git branch name: создается новый указатель на текущий коммит
 *      - т.е. master и новая ветка могут указывать на 1 и тот же коммит
 *      - автоматического переключения на новосозданную ветку НЕ происходит
 *          - для автоматического переключения: git checkout -b name
 *      - создание ОЧЕНЬ НЕ РЕСУРСОЗАТРАТНО
 *          - т.к. ветка является простым указателем на коммит
 *              - т.е. файлом из 40 символов
 *          - в отличие от других систем контроля версий
 *
 * - git branch: показать существующие ветки
 *      - * означает текущую
 *
 * - git branch -d name: удаление ветки (которая была слита или не отличается от текущей)
 *      - удаляет только ветку, на которой нет не слитых данных
 *          - все равно удалить ветку: git branch -D name
 *      - нужно не находится на ней в момент удаления
 *
 * - git branch -v: показать последние коммиты вместе с ветками
 *
 * - git branch --merged: показать только ветки, которые сливались с текущей
 *      - т.е. их можно удалять теперь
 *
 * - git branch --no-merged: показать только ветки, которые не сливались с текущей */


/*HEAD - УКАЗАТЕЛЬ НА ВЕТКУ, НА КОТОРОЙ Я НАХОЖУСЬ И КОММИТ, КОТОРЫЙ СТАНЕТ РОДИТЕЛЕМ СЛЕДУЮЩЕГО
 * - по 1 версии - это указатель на текущую ветку
 *      - посмотреть, на какую ветку указывает:
 *          - cat .git/HEAD:
 *              - напр. ref: refs/heads/master
 *          - или просто git branch
 *              - * будет отмечена моя текущая ветка
 *      - только вот если 2 ветки указывают на 1 коммит, то HEAD указывает на обе ветки
 *          - увидеть это можно при помощи git log
 *
 * - по 2 версии - это указатель на последний коммит, родитель следующего, для текущей ветки
 *      - посмотреть, на какой коммит указывает текущая ветка:
 *          - cat .git/refs/heads/master
 *              - где master получен от cat .git/HEAD
 *              - напр. 83226fe5000b9374ef3980a03a78bf407052ebff
 *      - при новом коммите автоматически сдвигается
 *      - как головка записи у магнитофона:
 *          - где бы она не находилась, с этого места начнется запись */


/* GIT CHECKOUT NAME - ПЕРЕХОД НА ДРУГУЮ ВЕТКУ
 * - переключение возможно только, если между ветками не возникнет конфикта!
 *      - в рабочем каталоге или индексе не должно быть незафиксированных изменений, которые
 *      конфликтуют с веткой, на которую осуществляется переход
 *          - т.к. изменения из рабочей директории и индекса переносятся при переходах
 *      - поэтому перед переключением лучше:
 *          - commit: закоммитить незакоммиченное
 *          - stash: спрятать незакоммиченное
 *
 * - git checkout -b name: создать ветку и сразу перейти на нее


/* GIT MERGE NAME - СЛИЯНИЕ ВЕТОК, АВТОМАТИЧЕСКОЕ И РУЧНОЕ РАЗРЕШЕНИЕ КОНФЛИКТОВ ПРИ СЛИЯНИИ
 * - нужно находиться на ветке, в которую будет сливаться указанная
 *      - сливаемая ветка потом не исчезает
 *          - нужно удалять вручную
 *
 * - git merge --abort: прервать процесс слияния
 *      - в случае возникновения конфликтов
 *
 * - автоматическое разрешение конфликтов:
 *      - Fast-Forward: история сливаемых коммитов не расходилась
 *          - т.е. ветка, на которой я нахожусь является прямым предком со сливаемой
 *          - указатель просто передвигается на ветку с дополнительным кодом
 *          - напр.
 *                          (fix)
 *                            |
 *                            D                      (fix)
 *                           /                         |
 *              было:   A-B-C           merge:   A-B-C-D
 *                          |                          |
 *                       (master)                   (master)
 *
 *
 *      - Recursive: история сливаемых коммитов разошлась
 *          - т.е. ветка, на которой я нахожусь не является прямым предком со сливаемой
 *              - в нее было уже добавлено что-то после создания сливаемой ветки
 *          - для слияния необходима основа
 *              - т.е. общий предок
 *                  - наиболее подходящий определяется автоматически
 *                      - такого не было в других СКВ
 *                          - и нужно было указывать вручную
 *          - в результате создается новый "коммит-слияние"
 *              - ссылается на оба своих предка
 *          - напр.
 *                          (fix)
 *                            |
 *                            D                          D (fix)
 *                           /                          / \|
 *              было:   A-B-C-E           merge:   A-B-C-E-F
 *                            |                            |
 *                         (master)                     (master)
 *
 *
 * - ручное разрешение конфликтов:
 *      - история сливаемых коммитов разошлась, и оба изменяют одну и ту же часть файла
 *      - все, что относится к конфликту, указано как unmerged в git status
 *      - Git также помечает конфликт в самом конфликтующем файле, напр:
 *          <<<<<<< HEAD
 *          feature code
 *          ||||||| merged common ancestors
 *          =======
 *          111
 *          >>>>>>> fix
 *          - где:
 *              - feature code - версия строка там, где находится HEAD
 *              - 111 - версия строки с ветки (fix), которая сливается с данной
 *      - чтобы разрешить конфликт, нужно:
 *          - для каждого конфликта выбрать подходящую версию или объединить их по усмотрению
 *              - после изменения добавить файл в индекс (git add) и закоммитить
 *                  - Git будет считать это разрешением конфликта
 *                      - поэтому ветка, которая вливалась в текущую, теперь будет считаться слитой
 *                          - несмотря на возможную разницу в коде
 *                          - если в ней, конечно, не произошло новых изменений
 *
 * - git mergetool: графическая оболочка для разрешения конфликтов */


/* REBASE (ПЕРЕМЕЩЕНИЕ) - ДРУГОЙ СПОСОБ ДОБАВЛЕНИЯ ИЗМЕНЕНИЙ ИЗ 1 ВЕТКИ В ДРУГУЮ
 * - при расхождении историй позволяет взять все изменения с 1 ветки и повторить их на другой без
 * создания нового коммита
 *      - тогда предком текущего коммита становится тот, с которым он сливается
 *          - и теперь можно слияться Fast-Forward через merge
 *
 * - делается для более аккуратной истории:
 *      - история будет выглядеть линейно:
 *          - без слияния 2 коммитов в 1 новый через Recursive
 *          - как будто работа велась последовательно, а не параллельно
 *          - иными словами: перемещение применяет изменения из одной линии разработки в другую в
 *          том порядке, в котором они были представлены, тогда как слияние объединяет вместе
 *          конечные точки 2 веток
 *
 * - процесс перемещения:
 *      - находится общий предок 2 веток
 *      - todo для каждого из коммитов в текущей ветке берется его дельта и сохраняется во временный файл
 *      - todo текущая ветка устанавливается на тот же коммит, что и ветка, на которую выполняется
 *      перемещение
 *      - одно за другим применяются все изменения
 *      - напр.
 *                 (experiment)
 *                      |
 *                      D                     (experiment)                      (experiment)
 *                     /                           |                                |
 *        было:   A-B-С-E        rebase:   A-B-С-Е-DE              merge:   A-B-С-Е-DE
 *                      |                        |                                  |
 *                   (master)                 (master)                           (master)
 *
 * - не забывай после перемещения делать merge, чтобы слить master на нужным коммитом!
 *
 * - git rebase branchname: добавить изменения с указанной ветки на текущую
 *
 * - git rebase mainbranchname branchname: применить изменения из ветки branchname на mainbranchname
 *
 * - git rebase --onto master server client: применить ветку client (ответвленную от server) к ветке
 * master
 *      - переключиться на ветку client
 *          - взять изменения от общего предка веток client и server
 *              - повторить их на master
 *      - т.е.:
 *            (master)                        (master) (client)
 *               |                                |      |
 *      С1-С2-С5-С6                     С1-С2-С5-С6-С8'-C9'
 *          \                                  \
 *           C3-C4-C10                          C3-C4-C10
 *            \     |           станет:                |
 *             \ (server)                           (server)
 *              \
 *               C8-C9
 *                   |
 *                (client)
 *
 * - git rebase --abort: прервать процесс при конфликте
 *
 * - НЕ ПЕРЕМЕЩАЙТЕ КОММИТЫ, КОТОРЫЕ ВЫ УЖЕ ОТПРАВИЛИ В ПУБЛИЧНЫЙ РЕПОЗИТОРИЙ
 *      - т.е. я сначала отправил коммиты на сервер, где последний коммит является слиянием 2
 *      (merge через Recursive)
 *      - кто-то начинает работать отталкиваясь от него
 *      - но я решаю вместо слияния сделать перемещение
 *          - т.е. последнего коммита-слияния не станет
 *              - т.к. это уже не Recursive, а перемещение + Fast-Forward
 *      - людям придется заново объединять свою работу с последним коммитом
 *          - т.к. этот коммит имеет уже другой SHA-1 хеш
 *      - кроме того, это приводит к путаннице в истории
 *      - т.е. любые перемещения нужно делать до публикации */


/* УДАЛЕННЫЕ ВЕТКИ (ORIGIN/MASTER) - (ЛОКАЛЬНЫЕ) УКАЗАТЕЛИ НА СОСТОЯНИЕ ВЕТОК В УДАЛЕННЫХ РЕПОЗИТОРИЯХ
 * - показывает (локально), куда ссылалась ветка на удаленном репозитории в момент последнего
 * подключения к нему
 *      - т.е. это просто локальная "удаленная" ветка
 *
 * - напр. при клонировании с удаленного репозитория:
 *      - ссылка на репозиторий будет названа origin
 *      - будут скопированы все данные
 *      - будет создан указатель на то, на что там указывает ветка master
 *          - он будет назван origin/master
 *          - он будет храниться локально
 *      - будет создана собственная локальная ветка master
 *          - изначально будет ссылаться на тот же коммит (локальный), на который ссылается master
 *          на origin
 *
 * - удаленную ветку нельзя перемещать локально
 *      - она двигается, когда осуществляется связь с удаленным репозиторием
 *          - если при этом кто-то на нем совершил push с момента последней связи
 *
 * - fetch извлекает с удаленного репозитория всю отстутвующую локально историю коммитов и
 * перемещает удаленную ветку (т.е. указатель origin/master) на последний из них
 *      - чтобы можно было работать с извлеченной веткой, ее нужно слить */


/* СОЗДАНИЕ/УДАЛЕНИЕ ЛОКАЛЬНОЙ ВЕТКИ ИЗ УДАЛЕННОЙ, ОТСЛЕЖИВАНИЕ
 * - создание локальной ветки из удаленной: git checkout -b branchname remotename/branchname
 *      - автоматически создает отслеживаемую ветку
 *
 * - отслеживаемая ветка: локальная ветка, которая напрямую связана с удаленной веткой
 *      - т.е. находясь на ней и используя push или pull, Git будет знать на какой удаленный
 *      репозиторий и его ветку нужно отправлять/принимать изменения
 *
 * - автоматическое отслеживание также создается при клонировании репозитория
 *      - ветка master отслеживает origin/master
 *
 * - git push remotename :branchname: удаление удаленной ветки */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ РАЗНОЕ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* GIT STASH - СОКРЫТИЕ ТЕКУЩИХ НАРАБОТОК В СТЕК ПЕРЕД ПЕРЕКЛЮЧЕНИЕМ ВЕТКИ
 * - зачем:
 *      - переключение ветки возможно только тогда, когда это не приводит к конфликту между ветками
 *      - текущая наработка не готова или не полностью готова к коммиту
 *
 * - восстановление возможно в любую ветку и в любое текущее состояние ветки
 *      - если возникнут конфликты при слиянии, их нужно решить
 *
 * - git stash: сокрытие всех "грязных" отслеживаемых файлов в рабочем каталоге и в индексе
 *      - если файл не отслеживается (только добавлен), его сначала придется проиндексировать
 *
 * - git stash save "comment": добавить комментарий при сокрытии
 *
 * - git stash list: показать список "заначек"
 *
 * - git stash apply: применить последнее спрятанное к текущему рабочему каталогу
 *      - все, что было в индексе при прятанье, помещается в рабочий каталог
 *      - когде не указывается имя спрятанного, подразумевается последнее спрятанное
 *
 * - git stash apply stash@{2}: применить указанное (stash@{2}) к текущему рабочему каталогу
 *
 * - git stash apply --index: применить последнее спрятанное также и к индексу
 *      - все, что было в индексе при прятанье, помещается в индекс
 *
 * - git stash drop stash@{2}: удалить указанное спрятанное из stash
 *      - при удалении одного спрятанного, нумерация у следующих меняется
 *          - т.е. при удалении stash@{2}, stash@{3} станет stash@{2}
 *
 * - git stash pop: применить последнее спрятанное и удалить из stash
 *
 * - git stash show -p stash@{0} | git apply -R: отменить указанное спрятанное
 *      - todo т.е. сначала нужно получить патч для спрятанных изменений
 *          - а затем применить его в перевернутом виде
 *
 * - git stash branch name: создать ветку со спрятанным и удалить спрятанное при успешном применении
 *      - когда было спрятано что-то, а после этого продолжалась работа на этой ветке, то пришлось
 *      бы решать много конфликтов слияния
 *      - началом ветки будет коммит, на котором я находился во время прятанья
 *
 * - у спрятанного нет SHA-1 хеша, связанного с ним */


/* ИГНОРИРОВАНИЕ ФАЙЛОВ
 * - чтобы не добавлялись автоматически в репозиторий и не отображались в списке неотслеживаемых
 *
 * - игнорирование при помощи шаблонов:
 *      - на уровне репозитория:
 *          - создать файл .gitignore на уровне каталога .git
 *      - на глобальном уровне:
 *          - создать файл .gitignore_global в C:/Users/takeoff/
 *
 * - правила шаблонов:
 *      - Пустые строки и строки, начинающиеся с #, игнорируются
 *      - Можно использовать стандартные glob шаблоны
 *           - glob шаблоны - упрощенные регулярные выражения
 *              - * - 0 или более символов
 *              - [abc] - любой символ из указанных в скобках
 *              - ? - любой 1 символ
 *              - [0-9] - любой символ из интервала
 *      - Можно заканчивать шаблон символом слэша (/) для указания каталога
 *      - Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого
 *      символа
 *
 * - список стандартных файлов для игнорирования: https://github.com/github/gitignore
 *
 * - Git игнорирует пустые директории
 *      - чтобы они отслеживались, нужно просто вставить в них какой-нибудь файл
 *          - напр. .gitkeep */


/* GIT RM - УДАЛЕНИЕ ФАЙЛА ИЗ ОТСЛЕЖИВАНИЯ И РАБОЧЕГО КАТАЛОГА
 * - чтобы удалить файл из репозитория, его сначала нужно перестать отслеживать
 *
 * - git rm:
 *      - удаление файла из отслеживания
 *      - удаление файла из рабочего каталога
 *      - факт удаления попадает в индекс
 *          - после этого нужно просто закоммитить изменения
 *
 * - git rm -f: то же самое, но когда файл был перед этим изменен или проиндексирован
 *
 * - git rm --cached: удаление файла из отслеживания, но оставление в каталоге
 *      - если забыл добавить в .gitignore, но уже проиндексировал/закоммитил
 *
 * - также можно использовать glob шаблоны для указания удаляемых файлов */


/* GIT MV - ПЕРЕМЕЩЕНИЕ/ПЕРЕИМЕНОВАНИЕ ФАЙЛОВ
 * - Git явно не следит за переименованием
 *       - т.е. не сохраняет в файле метаданные о переименовании
 *       - но обнаруживает переименование неявно
 *           - см. ниже
 *
 * - переименование: git mv file_from file_to
 *       - что эквивалентно:
 *           git mv file_from file_to // перемещение
 *           git rm file_from // удаление
 *           git add file_to // индексирование */


/* GIT TAG - ПОМЕТИТЬ КОММИТЫ
 * - напр. обозначить версию кода программы, соответвующую коммиту
 *      - т.е. напр. v1.4
 *
 * - git tag: просмотр существующих меток
 *      - перечисляет метки в алфавитном порядке
 *      - можно применять шаблон для поиска
 *
 * - типы меток:
 *      - аннотированные:
 *          - хранятся в базе данных Git как полноценные объекты
 *              - содержат:
 *                  - контрольную сумму
 *                  - дату
 *                  - имя поставившего метку
 *                  - имейл
 *                  - комментарий
 *          - git tag -a v1.4 -m 'my version 1.4': создание аннотированной метки для текущего коммита
 *              - без m будет запущен текстовый редактор
 *          - git show v1.4: показать данные вместе с помеченным коммитом
 *
 *      - легковесные:
 *          - простой указатель на определенный коммит
 *              - т.е. только контрольная сумма, сохраненная в файле
 *          - git tag v1.4-lw: создание легковесной метки для текущего коммита
 *              - т.е. без передачи опций
 *          - git show v1.4-lw: показать данные вместе с помеченным коммитом
 *
 * - можно помечать старые коммиты:
 *      git tag -a v1.2 -m 'version 1.2' 9fceb02
 *      - т.е. после сообщения указать контрольную сумму (или ее часть)
 *
 * - по дефолту push не отправляет метки на сервер
 *      - необходима явная отправка: git push origin [имя метки]
 *      - отправить много меток за раз: git push origin --tags */


/* ЛОКАЦИИ КОНФИГУРАЦИОННЫХ ФАЙЛОВ GIT
 * - /etc/gitconfig
 *       - настройки для всех пользователей
 *       - git config --system
 *       - находится там, где установлен Git
 *
 * - ~/.gitconfig
 *       - настройки конкретного пользователя
 *       - git config --global
 *       - на Windows ~ это C:\Documents and Settings\$USER или C:\Users\$USER
 *
 * - .git/config
 *       - настройки конкретного репозитория
 *
 * - настройки на каждом уровне подменяют настройки из предыдущих
 *       - т.е. настройки из .git/config переопределят более общие настройки ~/.gitconfig для
 *       репозитория
 *
 * - показать:
 *      - текущие настройки: git config --list
 *      - текущее значение настройки: git config user.name */


/* ИМЯ ПОЛЬЗОВАТЕЛЯ И ИМЕЙЛ
 * - необходимо указать, т.к. каждый коммит содержит эту информацию
 * - указать для текущего юзера (нужно только 1 раз):
 *      git config --global user.name "John Doe"
 *      git config --global user.email johndoe@example.com */


/* ТЕКСТОВЫЙ РЕДАКТОР
 * - будет использоваться, когда нужно набрать сообщение в Git
 * - по умолчанию это стандартный редактов системы
 * - изменить:
 *      $ git config --global core.editor emacs */


/* ПОЛУЧЕНИЕ ПОМОЩИ (СПРАВКИ) ДЛЯ ЛЮБОЙ КОМАНДЫ
 * - git help <команда>
 * - git <команда> --help
 * - man git-<команда> */


/* ПСЕВДОНИМЫ
 * - для команд можно сделать псевдонимы:
 *      git config --global alias.unstage 'reset HEAD --'
 *      git config --global alias.last 'log -1 HEAD'
 *      git config --global alias.stash-unapply '!git stash show -p | git apply -R'
 *      git config --global alias.present "log --oneline --graph --all --decorate"
 *
 * - также можно заменить псевдонимом внешнюю команду при помощи !
 *      git config --global alias.visual '!gitk'
 *
 * - существующие псевдонимы можно посмотреть в конфигурации
 *      git config --list */


/*======================================================================*/
/* ОСНОВНЫЕ КОМАНДЫ
 * git help: список команд
 *
 * git config --global user.name "John Doe": пример изменения настроек
 *
 * cat .git/config - конфигурационный файл текущего репозитория
 *       - там, напр., есть список удаленных репозиториев
 *
 * cat .git/HEAD: узнать, где сейчас HEAD
 *
 * cat .git/refs/heads/master: узнать, где мастер
 *
 * git config --global alias.st "status": назначить алиас для комманды (co = checkout, ci = commit,
 * br = branch, logg = log --graph --decorate --oneline --abbrev-commit --all)
 *
 * git init: инициализация отслеживания папки
 *
 * удалить отслеживание - просто удалить .git
 *
 * git log: список коммитов
 *
 * git log -n 3: список последних 3 коммитов
 *
 * git log --since=2017-08-12: начиная с даты
 *
 * git log --until=2017-08-12: по дату
 *
 * git log --author="takeoff": по автору
 *
 * git log --grep="fix": поиск по заданному тексту
 *
 * git log --graph: графическое представление истории
 *
 * git log --oneline --graph --all --decorate: то же, но компактнее + плюс где HEAD и мастер
 *
 * git show [commit]: детальная инфа по коммиту
 *
 * git diff [commit] [file]: показать чем отличается текущий файл, от его в коммите
 *
 * git diff [commit] [commit]: показать чем отличается 1 коммит от другого
 *
 * git diff [branch]..[branch]: сравнить 2 ветки
 *
 * git diff: сравнить файл в репозитории с тем, что в рабочей директории
 *
 * git diff --staged: сравнить файл в репозитории с тем, что в индексе
 *
 * git diff --name-status master..branchName: список файлов с различиями между ветками
 *
 * git status: различия между рабочей директорией, индексом и репозиторием
 *
 * git add .: добавить все изменения из рабочей директории в индекс
 *
 * git commit -m "comment": запись скриншота в историю версий (репозиторий)
 *
 * git commit --amend: изменить последний коммит на тот, что в индексе
 *
 * git rm: удалить файл из рабочей директории и подготовить удаление через индекс
 *
 * git rm --cashed: удалить файл из индекса, но оставить в рабочей директории
 *
 * git rm --cached [file]: перестать отслеживать файл (также нужно добавить в .gitignore)
 *
 * git mv [file-original] [file-renamed]: переименовать
 *
 * git checkout [branch]: переключиться на указанную ветку и проапдейтить рабочую директорию
 *
 * git checkout -- [file]: остаться в текущей ветке и проапдейтить рабочую директорию файлом из
 * репозитория
 *
 * git checkout [commit] -- [file]: остаться в текущей ветке и проапдейтить рабочую директорию
 * файлом из репозитория
 *
 * git checkout -b [name]: создать новую ветку и переключиться на нее
 *
 * git reset [file]: убрать изменения из индекса
 *
 * git reset [commit]: отменить все коммиты после указанного, сохранив изменения локально
 *
 * git revert [commit] - отменить коммит
 *
 * git clean: удалить не отслеживаемые файлы из рабочей директории
 *
 * git branch: список веток проекта
 *
 * git branch [name]: создать новую ветку
 *
 * git branch -m [new name]: переименовать ветку
 *
 * git branch -d [name]: удалить ветку (сначала выйти из нее) - если есть разница, предложит слиться.
 * Чтоб не спрашивал -D
 *
 * git branch -a: показать все ветки с учетом удаленных
 *
 * git merge [branch]: сливает указанную ветку в текущую
 *
 * git merge --abort: прервать состояние слияния (когда есть конфликты, но перехотелось их сейчас
 * решать)
 *
 * git merge -no-ff [branch]: при возможности быстрого слияния, создать новый коммит (а не
 * использовать текущий)
 *
 * git remote - список известных удаленных репозиториев
 *
 * git remote -v - чуть развернутей список удаленных репозиториев
 *
 * git remote add [alias] [url]: - добавить удаленный сервер по ссылке и по указанному имени
 *
 * git remote rm [alias] - удалить удаленный репозиторий (локально)
 *
 * git push -u [alias] [branch] - отправить на указанный удаленный репозиторий указанную ветку.
 * -u: указанная локальная ветка будет отслеживать данную ветку на указанном удаленном репозитории
 *
 * git pull origin branchname --allow-unrelated-histories: убрать ошибку fatal: refusing to merge
 * unrelated histories, когда в первый раз стягиваешь remote в локальный репозиторий
 *
 * git clone [url] [local repository]: сделать локальную копию из существующего удаленного репозитория
 *
 * git push: отправляет изменения на отслеживаемую ветку
 *
 * git push origin --delete [branch]: удалить ветку на удаленном сервере
 *
 * git stash: поместить грязные файлы в рабочей директории и индексе в стеш
 *
 * git stash save "comment": сохранить в стеш
 *
 * git stash list: список того, что в стеше
 *
 * git stash apply --index: вернуть последний снимок из стеша, в том числе с индексом
 *
 * git apply stash@{2}: вернуть второй снимок
 *
 * git stash drop: удалить снимок из стеша
 *
 * git stash pop: достать из стеша и удалить его оттуда
 *
 * git stash show -p | git apply -R: когда внесенные изменения не устроили и надо сделать "unapply"
 *
 * git stash branch [newbranch]: создание новой ветки, где первым коммитом будет тот, для которого
 * был сделан стеш, восстановление спрятонного из стеша и, при успешном восстановлении, удалении
 * стеша */